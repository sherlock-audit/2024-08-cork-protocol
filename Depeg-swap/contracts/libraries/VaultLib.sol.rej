diff a/Depeg-swap/contracts/libraries/VaultLib.sol b/Depeg-swap/contracts/libraries/VaultLib.sol	(rejected hunks)
@@ -1,8 +1,8 @@
-pragma solidity 0.8.24;
+pragma solidity ^0.8.24;
 
 import {State, VaultState, VaultConfig, VaultWithdrawalPool, VaultAmmLiquidityPool} from "./State.sol";
 import {VaultConfigLibrary} from "./VaultConfig.sol";
-import {Pair, PairLibrary} from "./Pair.sol";
+import {Pair, PairLibrary, Id} from "./Pair.sol";
 import {LvAsset, LvAssetLibrary} from "./LvAssetLib.sol";
 import {PsmLibrary} from "./PsmLib.sol";
 import {PsmRedemptionAssetManager, RedemptionAssetManagerLibrary} from "./RedemptionAssetManagerLib.sol";
@@ -42,6 +42,15 @@ library VaultLibrary {
     /// @notice inssuficient balance to perform expiry redeem(e.g requesting 5 LV to redeem but trying to redeem 10)
     error InsufficientBalance(address caller, uint256 requested, uint256 balance);
 
+    /// @notice insufficient output amount, e.g trying to redeem 100 LV whcih you expect 100 RA but only received 50 RA
+    error InsufficientOutputAmount(uint256 amountOutMin, uint256 received);
+
+    // for avoiding stack too deep errors
+    struct Tolerance {
+        uint256 ra;
+        uint256 ct;
+    }
+
     function initialize(VaultState storage self, address lv, uint256 fee, address ra, uint256 initialDsPrice)
         external
     {
@@ -58,34 +67,39 @@ library VaultLibrary {
         uint256 ctAmount,
         address raAddress,
         address ctAddress,
-        IUniswapV2Router02 ammRouter
+        IUniswapV2Router02 ammRouter,
+        uint256 raTolerance,
+        uint256 ctTolerance
     ) internal {
-        (uint256 raTolerance, uint256 ctTolerance) =
-            MathHelper.calculateWithTolerance(raAmount, ctAmount, MathHelper.UNIV2_STATIC_TOLERANCE);
+        IERC20(raAddress).safeIncreaseAllowance(address(ammRouter), raAmount);
+        IERC20(ctAddress).safeIncreaseAllowance(address(ammRouter), ctAmount);
 
-        ERC20(raAddress).approve(address(ammRouter), raAmount);
-        ERC20(ctAddress).approve(address(ammRouter), ctAmount);
+        (uint256 raAdded, uint256 ctAdded, uint256 lp) = ammRouter.addLiquidity(
+            raAddress, ctAddress, raAmount, ctAmount, raTolerance, ctTolerance, address(this), block.timestamp
+        );
 
-        (address token0, address token1, uint256 token0Amount, uint256 token1Amount) =
-            MinimalUniswapV2Library.sortTokensUnsafeWithAmount(raAddress, ctAddress, raAmount, ctAmount);
-        (,, uint256 token0Tolerance, uint256 token1Tolerance) =
-            MinimalUniswapV2Library.sortTokensUnsafeWithAmount(raAddress, ctAddress, raTolerance, ctTolerance);
+        uint256 dustCt = ctAmount - ctAdded;
 
-        (,, uint256 lp) = ammRouter.addLiquidity(
-            token0, token1, token0Amount, token1Amount, token0Tolerance, token1Tolerance, address(this), block.timestamp
-        );
+        if (dustCt > 0) {
+            SafeERC20.safeTransfer(IERC20(ctAddress), msg.sender, dustCt);
+        }
+
+        uint256 dustRa = raAmount - raAdded;
 
+        if (dustRa > 0) {
+            SafeERC20.safeTransfer(IERC20(raAddress), msg.sender, dustRa);
+        }
         self.vault.config.lpBalance += lp;
     }
 
-    function _addFlashSwapReserve(
+    function _addFlashSwapReserveLv(
         State storage self,
         IDsFlashSwapCore flashSwapRouter,
         DepegSwap storage ds,
         uint256 amount
     ) internal {
-        Asset(ds._address).approve(address(flashSwapRouter), amount);
-        flashSwapRouter.addReserve(self.info.toId(), self.globalAssetIdx, amount);
+        IERC20(ds._address).safeIncreaseAllowance(address(flashSwapRouter), amount);
+        flashSwapRouter.addReserveLv(self.info.toId(), self.globalAssetIdx, amount);
     }
 
     // MUST be called on every new DS issuance
@@ -93,7 +107,8 @@ library VaultLibrary {
         State storage self,
         uint256 prevDsId,
         IDsFlashSwapCore flashSwapRouter,
-        IUniswapV2Router02 ammRouter
+        IUniswapV2Router02 ammRouter,
+        uint256 deadline
     ) external {
         // do nothing at first issuance
         if (prevDsId == 0) {
@@ -101,7 +116,7 @@ library VaultLibrary {
         }
 
         if (!self.vault.lpLiquidated.get(prevDsId)) {
-            _liquidatedLp(self, prevDsId, ammRouter, flashSwapRouter);
+            _liquidatedLp(self, prevDsId, ammRouter, flashSwapRouter, deadline);
         }
 
         __provideAmmLiquidityFromPool(self, flashSwapRouter, self.ds[self.globalAssetIdx].ct, ammRouter);
@@ -125,15 +140,39 @@ library VaultLibrary {
         uint256 amount,
         IDsFlashSwapCore flashSwapRouter,
         address ctAddress,
-        IUniswapV2Router02 ammRouter
+        IUniswapV2Router02 ammRouter,
+        Tolerance memory tolerance
     ) internal returns (uint256 ra, uint256 ct) {
-        uint256 dsId = self.globalAssetIdx;
+        (ra, ct) = __calculateProvideLiquidityAmount(self, amount, flashSwapRouter);
+
+        __provideLiquidity(self, ra, ct, flashSwapRouter, ctAddress, ammRouter, tolerance, amount);
+    }
 
+    function __calculateProvideLiquidityAmount(State storage self, uint256 amount, IDsFlashSwapCore flashSwapRouter)
+        internal
+        view
+        returns (uint256 ra, uint256 ct)
+    {
+        uint256 dsId = self.globalAssetIdx;
         uint256 ctRatio = __getAmmCtPriceRatio(self, flashSwapRouter, dsId);
+        uint256 exchangeRates = self.ds[dsId].exchangeRate();
+
+        (ra, ct) = MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice(amount, ctRatio, exchangeRates);
+    }
 
-        (ra, ct) = MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice(amount, ctRatio);
+    function __provideLiquidityWithRatio(
+        State storage self,
+        uint256 amount,
+        IDsFlashSwapCore flashSwapRouter,
+        address ctAddress,
+        IUniswapV2Router02 ammRouter
+    ) internal returns (uint256 ra, uint256 ct) {
+        (uint256 raTolerance, uint256 ctTolerance) =
+            MathHelper.calculateWithTolerance(ra, ct, MathHelper.UNIV2_STATIC_TOLERANCE);
 
-        __provideLiquidity(self, ra, ct, flashSwapRouter, ctAddress, ammRouter, dsId);
+        __provideLiquidityWithRatio(
+            self, amount, flashSwapRouter, ctAddress, ammRouter, Tolerance(raTolerance, ctTolerance)
+        );
     }
 
     function __getAmmCtPriceRatio(State storage self, IDsFlashSwapCore flashSwapRouter, uint256 dsId)
@@ -141,13 +180,50 @@ library VaultLibrary {
         view
         returns (uint256 ratio)
     {
-        // This basically means that if the reserve is empty, then we use the default ratio supplied at deployment
-        ratio = self.ds[dsId].exchangeRate() - self.vault.initialDsPrice;
+        Id id = self.info.toId();
+        uint256 exchangeRate = self.ds[dsId].exchangeRate();
+        uint256 hpa = flashSwapRouter.getCurrentEffectiveHPA(id);
+        bool isRollover = flashSwapRouter.isRolloverSale(id, dsId);
+
+        uint256 marketRatio;
 
-        // will always fail for the first deposit
-        try flashSwapRouter.getCurrentPriceRatio(self.info.toId(), dsId) returns (uint256, uint256 _ctRatio) {
-            ratio = _ctRatio;
-        } catch {}
+        try flashSwapRouter.getCurrentPriceRatio(id, dsId) returns (uint256, uint256 _marketRatio) {
+            marketRatio = _marketRatio;
+        } catch {
+            marketRatio = 0;
+        }
+
+        ratio = _determineRatio(hpa, marketRatio, self.vault.initialDsPrice, exchangeRate, isRollover, dsId);
+    }
+
+    function _determineRatio(
+        uint256 hpa,
+        uint256 marketRatio,
+        uint256 initialDsPrice,
+        uint256 exchangeRate,
+        bool isRollover,
+        uint256 dsId
+    ) internal pure returns (uint256 ratio) {
+        // fallback to initial ds price ratio if hpa is 0, and market ratio is 0
+        // usually happens when there's no trade on the router AND is not the first issuance
+        // OR it's the first issuance
+        if (hpa == 0 && marketRatio == 0) {
+            ratio = exchangeRate - initialDsPrice;
+            return ratio;
+        }
+
+        // this will return the hpa as ratio when it's basically not the first issuance, and there's actually an hpa to rely on
+        // we must specifically check for market ratio since, we want to trigger this only when there's no market ratio(i.e freshly after a rollover)
+        if (dsId != 1 && isRollover && hpa != 0 && marketRatio == 0) {
+            ratio = exchangeRate - hpa;
+            return ratio;
+        }
+
+        // this will be the default ratio to use
+        if (marketRatio != 0) {
+            ratio = marketRatio;
+            return ratio;
+        }
     }
 
     function __provideLiquidity(
@@ -157,18 +233,22 @@ library VaultLibrary {
         IDsFlashSwapCore flashSwapRouter,
         address ctAddress,
         IUniswapV2Router02 ammRouter,
-        uint256 dsId
+        Tolerance memory tolerance,
+        uint256 amountRaOriginal
     ) internal {
+        uint256 dsId = self.globalAssetIdx;
+
         // no need to provide liquidity if the amount is 0
         if (raAmount == 0 && ctAmount == 0) {
             return;
         }
 
-        PsmLibrary.unsafeIssueToLv(self, ctAmount);
-
-        __addLiquidityToAmmUnchecked(self, raAmount, ctAmount, self.info.redemptionAsset(), ctAddress, ammRouter);
+        PsmLibrary.unsafeIssueToLv(self, MathHelper.calculateProvideLiquidityAmount(amountRaOriginal, raAmount));
 
-        _addFlashSwapReserve(self, flashSwapRouter, self.ds[dsId], ctAmount);
+        __addLiquidityToAmmUnchecked(
+            self, raAmount, ctAmount, self.info.redemptionAsset(), ctAddress, ammRouter, tolerance.ra, tolerance.ct
+        );
+        _addFlashSwapReserveLv(self, flashSwapRouter, self.ds[dsId], ctAmount);
     }
 
     function __provideAmmLiquidityFromPool(
@@ -181,9 +261,16 @@ library VaultLibrary {
 
         uint256 ctRatio = __getAmmCtPriceRatio(self, flashSwapRouter, dsId);
 
-        (uint256 ra, uint256 ct) = self.vault.pool.rationedToAmm(ctRatio);
+        (uint256 ra, uint256 ct, uint256 originalBalance) =
+            self.vault.pool.rationedToAmm(ctRatio, self.ds[dsId].exchangeRate());
 
-        __provideLiquidity(self, ra, ct, flashSwapRouter, ctAddress, ammRouter, dsId);
+        // this doesn't really matter tbh, since the amm is fresh and we're the first one to add liquidity to it
+        (uint256 raTolerance, uint256 ctTolerance) =
+            MathHelper.calculateWithTolerance(ra, ct, MathHelper.UNIV2_STATIC_TOLERANCE);
+
+        __provideLiquidity(
+            self, ra, ct, flashSwapRouter, ctAddress, ammRouter, Tolerance(raTolerance, ctTolerance), originalBalance
+        );
 
         self.vault.pool.resetAmmPool();
     }
@@ -193,78 +280,68 @@ library VaultLibrary {
         address from,
         uint256 amount,
         IDsFlashSwapCore flashSwapRouter,
-        IUniswapV2Router02 ammRouter
-    ) external {
+        IUniswapV2Router02 ammRouter,
+        uint256 raTolerance,
+        uint256 ctTolerance
+    ) external returns (uint256 received) {
         if (amount == 0) {
             revert ICommon.ZeroDeposit();
         }
-
         safeBeforeExpired(self);
-        self.vault.balances.ra.lockUnchecked(amount, from);
-        __provideLiquidityWithRatio(self, amount, flashSwapRouter, self.ds[self.globalAssetIdx].ct, ammRouter);
-        self.vault.lv.issue(from, amount);
-    }
 
-    // preview a deposit action with current exchange rate,
-    // returns the amount of shares(share pool token) that user will receive
-    function previewDeposit(uint256 amount) external pure returns (uint256 lvReceived) {
-        if (amount == 0) {
-            revert ICommon.ZeroDeposit();
-        }
-
-        lvReceived = amount;
-    }
+        uint256 exchangeRate;
 
-    function requestRedemption(
-        State storage self,
-        address owner,
-        uint256 amount,
-        bytes memory rawLvPermitSig,
-        uint256 deadline
-    ) external {
-        safeBeforeExpired(self);
-        if (deadline != 0) {
-            DepegSwapLibrary.permit(self.vault.lv._address, rawLvPermitSig, owner, address(this), amount, deadline);
+        // we mint 1:1 if it's the first deposit
+        if (!self.vault.initialized) {
+            exchangeRate = 1 ether;
+            self.vault.initialized = true;
+        } else {
+            // else we get the current exchange rate of LV
+            (exchangeRate,,) = previewRedeemEarly(self, 1 ether, flashSwapRouter);
         }
-        self.vault.pool.withdrawEligible[owner] += amount;
-        self.vault.pool.withdrawalPool.atrributedLv += amount;
-        self.vault.lv.lockFrom(amount, owner);
-    }
 
-    function lvLockedFor(State storage self, address owner) external view returns (uint256) {
-        return self.vault.pool.withdrawEligible[owner];
-    }
+        self.vault.balances.ra.lockUnchecked(amount, from);
+        __provideLiquidityWithRatio(
+            self, amount, flashSwapRouter, self.ds[self.globalAssetIdx].ct, ammRouter, Tolerance(raTolerance, ctTolerance)
+        );
 
-    function cancelRedemptionRequest(State storage self, address owner, uint256 amount) external {
-        safeBeforeExpired(self);
-        uint256 userEligible = self.vault.pool.withdrawEligible[owner];
+        // then we calculate how much LV we will get for the amount of RA we deposited with the exchange rate
+        // this is to seprate the yield vs the actual deposit amount. so when a user withdraws their LV, they get their accrued yield properly
+        amount = MathHelper.calculateDepositAmountWithExchangeRate(amount, exchangeRate);
 
-        if (userEligible == 0) {
-            revert Unauthorized(msg.sender);
-        }
-
-        if (userEligible < amount) {
-            revert InsufficientBalance(owner, amount, userEligible);
-        }
+        self.vault.lv.issue(from, amount);
 
-        self.vault.pool.withdrawEligible[owner] -= amount;
-        self.vault.pool.withdrawalPool.atrributedLv -= amount;
-        self.vault.lv.unlockTo(amount, owner);
+        received = amount;
     }
 
-    function transferRedemptionRights(State storage self, address from, address to, uint256 amount) external {
-        uint256 initialOwneramount = self.vault.pool.withdrawEligible[from];
-
-        if (initialOwneramount == 0) {
-            revert Unauthorized(msg.sender);
+    // preview a deposit action with current exchange rate,
+    // returns the amount of shares(share pool token) that user will receive
+    function previewDeposit(State storage self, IDsFlashSwapCore flashSwapRouter, uint256 amount)
+        external
+        view
+        returns (uint256 lvReceived, uint256 raAddedAsLiquidity, uint256 ctAddedAsLiquidity)
+    {
+        uint256 exchangeRate;
+
+        // we mint 1:1 if it's the first deposit
+        if (!self.vault.initialized) {
+            exchangeRate = 1 ether;
+        } else {
+            // else we get the current exchange rate of LV
+            (exchangeRate,,) = previewRedeemEarly(self, 1 ether, flashSwapRouter);
         }
 
-        if (initialOwneramount < amount) {
-            revert InsufficientBalance(from, amount, initialOwneramount);
-        }
+        // then we calculate how much LV we will get for the amount of RA we deposited with the exchange rate
+        // this is to seprate the yield vs the actual deposit amount. so when a user withdraws their LV, they get their accrued yield properly
+        amount = MathHelper.calculateDepositAmountWithExchangeRate(amount, exchangeRate);
+
+        (raAddedAsLiquidity, ctAddedAsLiquidity) = MathHelper.calculateProvideLiquidityAmountBasedOnCtPrice(
+            amount,
+            __getAmmCtPriceRatio(self, flashSwapRouter, self.globalAssetIdx),
+            self.ds[self.globalAssetIdx].exchangeRate()
+        );
 
-        self.vault.pool.withdrawEligible[to] += amount;
-        self.vault.pool.withdrawEligible[from] -= amount;
+        lvReceived = amount;
     }
 
     function __liquidateUnchecked(
@@ -273,17 +350,13 @@ library VaultLibrary {
         address ctAddress,
         IUniswapV2Router02 ammRouter,
         IUniswapV2Pair ammPair,
-        uint256 lp
+        uint256 lp,
+        uint256 deadline
     ) internal returns (uint256 raReceived, uint256 ctReceived) {
         ammPair.approve(address(ammRouter), lp);
 
         // amountAMin & amountBMin = 0 for 100% tolerence
-        (raReceived, ctReceived) =
-            ammRouter.removeLiquidity(raAddress, ctAddress, lp, 0, 0, address(this), block.timestamp);
-
-        (raReceived, ctReceived) = MinimalUniswapV2Library.reverseSortWithAmount224(
-            ammPair.token0(), ammPair.token1(), raAddress, ctAddress, raReceived, ctReceived
-        );
+        (raReceived, ctReceived) = ammRouter.removeLiquidity(raAddress, ctAddress, lp, 0, 0, address(this), deadline);
 
         self.vault.config.lpBalance -= lp;
     }
@@ -294,25 +367,44 @@ library VaultLibrary {
         uint256 dsId,
         IDsFlashSwapCore flashSwapRouter,
         IUniswapV2Router02 ammRouter,
-        uint256 lvRedeemed
+        uint256 lvRedeemed,
+        uint256 deadline
     ) internal returns (uint256 ra) {
-        uint256 raPerLp;
-        uint256 ctPerLp;
-        uint256 raPerLv;
         uint256 ammCtBalance;
 
-        (raPerLv,, raPerLp, ctPerLp) = __calculateCtBalanceWithRate(self, flashSwapRouter, dsId);
+        (ra, ammCtBalance) = __calculateAndLiquidate(self, dsId, flashSwapRouter, ammRouter, lvRedeemed, deadline);
+
+        ra += _redeemCtDsAndSellExcessCt(self, dsId, ammRouter, flashSwapRouter, ammCtBalance, deadline);
+    }
+
+    function __calculateAndLiquidate(
+        State storage self,
+        uint256 dsId,
+        IDsFlashSwapCore flashSwapRouter,
+        IUniswapV2Router02 ammRouter,
+        uint256 lvRedeemed,
+        uint256 deadline
+    ) private returns (uint256 ra, uint256 ammCtBalance) {
+        DepegSwap storage ds = self.ds[dsId];
+
+        uint256 lpliquidated = _calculateLpEquivalent(self, dsId, flashSwapRouter, lvRedeemed);
 
         (ra, ammCtBalance) = __liquidateUnchecked(
-            self,
-            self.info.pair1,
-            self.ds[dsId].ct,
-            ammRouter,
-            IUniswapV2Pair(self.ds[dsId].ammPair),
-            MathHelper.convertToLp(raPerLv, raPerLp, lvRedeemed)
+            self, self.info.pair1, ds.ct, ammRouter, IUniswapV2Pair(ds.ammPair), lpliquidated, deadline
         );
+    }
+
+    function _calculateLpEquivalent(
+        State storage self,
+        uint256 dsId,
+        IDsFlashSwapCore flashSwapRouter,
+        uint256 lvRedeemed
+    ) private view returns (uint256 lpRemoved) {
+        uint256 raPerLp;
+        uint256 raPerLv;
 
-        ra += _redeemCtDsAndSellExcessCt(self, dsId, ammRouter, flashSwapRouter, ammCtBalance);
+        (raPerLv,, raPerLp,) = __calculateCtBalanceWithRate(self, flashSwapRouter, dsId);
+        lpRemoved = MathHelper.convertToLp(raPerLv, raPerLp, lvRedeemed);
     }
 
     function _redeemCtDsAndSellExcessCt(
@@ -320,29 +412,29 @@ library VaultLibrary {
         uint256 dsId,
         IUniswapV2Router02 ammRouter,
         IDsFlashSwapCore flashSwapRouter,
-        uint256 ammCtBalance
+        uint256 ammCtBalance,
+        uint256 deadline
     ) internal returns (uint256 ra) {
         uint256 reservedDs = flashSwapRouter.getLvReserve(self.info.toId(), dsId);
 
         uint256 redeemAmount = reservedDs >= ammCtBalance ? ammCtBalance : reservedDs;
 
-        reservedDs = flashSwapRouter.emptyReservePartial(self.info.toId(), dsId, redeemAmount);
+        flashSwapRouter.emptyReservePartialLv(self.info.toId(), dsId, redeemAmount);
 
-        ra += redeemAmount;
-        PsmLibrary.lvRedeemRaWithCtDs(self, redeemAmount, dsId);
+        ra += PsmLibrary.lvRedeemRaWithCtDs(self, redeemAmount, dsId);
 
-        uint256 ctSellAmount = reservedDs >= ammCtBalance ? 0 : ammCtBalance - reservedDs;
+        // we subtract redeem amount since we already liquidate it from the router
+        uint256 ctSellAmount = reservedDs - redeemAmount >= ammCtBalance ? 0 : ammCtBalance - redeemAmount;
 
         DepegSwap storage ds = self.ds[dsId];
         address[] memory path = new address[](2);
         path[0] = ds.ct;
         path[1] = self.info.pair1;
 
-        ERC20(ds.ct).approve(address(ammRouter), ctSellAmount);
-
         if (ctSellAmount != 0) {
+            IERC20(ds.ct).safeIncreaseAllowance(address(ammRouter), ctSellAmount);
             // 100% tolerance, to ensure this not fail
-            ra += ammRouter.swapExactTokensForTokens(ctSellAmount, 0, path, address(this), block.timestamp)[1];
+            ra += ammRouter.swapExactTokensForTokens(ctSellAmount, 0, path, address(this), deadline)[1];
         }
     }
 
@@ -350,12 +442,14 @@ library VaultLibrary {
         State storage self,
         uint256 dsId,
         IUniswapV2Router02 ammRouter,
-        IDsFlashSwapCore flashSwapRouter
+        IDsFlashSwapCore flashSwapRouter,
+        uint256 deadline
     ) internal {
         DepegSwap storage ds = self.ds[dsId];
+        uint256 lpBalance = self.vault.config.lpBalance;
 
         // if there's no LP, then there's nothing to liquidate
-        if (self.vault.config.lpBalance == 0) {
+        if (lpBalance == 0) {
             return;
         }
 
@@ -364,21 +458,31 @@ library VaultLibrary {
         // 2. Any excess DS in the LV is paired with CT to redeem RA
         // 3. The excess CT is used to claim RA + PA in the PSM
         // 4. End state: Only RA + redeemed PA remains
-
         self.vault.lpLiquidated.set(dsId);
 
         (uint256 raAmm, uint256 ctAmm) = __liquidateUnchecked(
-            self, self.info.pair1, self.ds[dsId].ct, ammRouter, IUniswapV2Pair(ds.ammPair), self.vault.config.lpBalance
+            self, self.info.pair1, ds.ct, ammRouter, IUniswapV2Pair(ds.ammPair), lpBalance, deadline
         );
 
-        uint256 reservedDs = flashSwapRouter.emptyReserve(self.info.toId(), dsId);
+        // avoid stack too deep error
+        _pairAndRedeemCtDs(self, flashSwapRouter, dsId, ctAmm, raAmm);
+    }
 
-        uint256 redeemAmount = reservedDs >= ctAmm ? ctAmm : reservedDs;
-        PsmLibrary.lvRedeemRaWithCtDs(self, redeemAmount, dsId);
+    function _pairAndRedeemCtDs(
+        State storage self,
+        IDsFlashSwapCore flashSwapRouter,
+        uint256 dsId,
+        uint256 ctAmm,
+        uint256 raAmm
+    ) private returns (uint256 redeemAmount, uint256 ctAttributedToPa) {
+        uint256 reservedDs = flashSwapRouter.emptyReserveLv(self.info.toId(), dsId);
+
+        redeemAmount = reservedDs >= ctAmm ? ctAmm : reservedDs;
+        redeemAmount = PsmLibrary.lvRedeemRaWithCtDs(self, redeemAmount, dsId);
 
         // if the reserved DS is more than the CT that's available from liquidating the AMM LP
         // then there's no CT we can use to effectively redeem RA + PA from the PSM
-        uint256 ctAttributedToPa = reservedDs >= ctAmm ? 0 : ctAmm - reservedDs;
+        ctAttributedToPa = reservedDs >= ctAmm ? 0 : ctAmm - reservedDs;
 
         uint256 psmPa;
         uint256 psmRa;
@@ -387,14 +491,9 @@ library VaultLibrary {
             (psmPa, psmRa) = PsmLibrary.lvRedeemRaPaWithCt(self, ctAttributedToPa, dsId);
         }
 
-        psmRa += redeemAmount;
-
-        self.vault.pool.reserve(self.vault.lv.totalIssued(), raAmm + psmRa, psmPa);
-    }
+        psmRa += redeemAmount + raAmm;
 
-    function reservedForWithdrawal(State storage self) external view returns (uint256 ra, uint256 pa) {
-        ra = self.vault.pool.withdrawalPool.raBalance;
-        pa = self.vault.pool.withdrawalPool.paBalance;
+        self.vault.pool.reserve(self.vault.lv.totalIssued(), psmRa, psmPa);
     }
 
     function _tryLiquidateLpAndRedeemCtToPsm(State storage self, uint256 dsId, IDsFlashSwapCore flashSwapRouter)
@@ -427,10 +526,16 @@ library VaultLibrary {
         view
         returns (uint256 totalRa, uint256 ammCtBalance)
     {
-        (uint256 raReserve, uint256 ctReserve,) = flashSwapRouter.getUniV2pair(self.info.toId(), dsId).getReserves();
+        IUniswapV2Pair ammPair = flashSwapRouter.getUniV2pair(self.info.toId(), dsId);
+
+        (uint256 raReserve, uint256 ctReserve,) = ammPair.getReserves();
+
+        (raReserve, ctReserve) = MinimalUniswapV2Library.reverseSortWithAmount224(
+            ammPair.token0(), ammPair.token1(), self.info.pair1, self.ds[dsId].ct, raReserve, ctReserve
+        );
 
         (,,,, totalRa, ammCtBalance) = __calculateTotalRaAndCtBalanceWithReserve(
-            self, raReserve, ctReserve, flashSwapRouter.getLvReserve(self.info.toId(), dsId)
+            self, raReserve, ctReserve, flashSwapRouter.getUniV2pair(self.info.toId(), dsId).totalSupply()
         );
     }
 
@@ -442,8 +547,17 @@ library VaultLibrary {
     {
         (uint256 raReserve, uint256 ctReserve,) = flashSwapRouter.getUniV2pair(self.info.toId(), dsId).getReserves();
 
+        (raReserve, ctReserve) = MinimalUniswapV2Library.reverseSortWithAmount224(
+            flashSwapRouter.getUniV2pair(self.info.toId(), dsId).token0(),
+            flashSwapRouter.getUniV2pair(self.info.toId(), dsId).token1(),
+            self.info.pair1,
+            self.ds[dsId].ct,
+            raReserve,
+            ctReserve
+        );
+
         (,, raPerLv, ctPerLv, raPerLp, ctPerLp) = __calculateTotalRaAndCtBalanceWithReserve(
-            self, raReserve, ctReserve, flashSwapRouter.getLvReserve(self.info.toId(), dsId)
+            self, raReserve, ctReserve, flashSwapRouter.getUniV2pair(self.info.toId(), dsId).totalSupply()
         );
     }
 
@@ -475,24 +589,45 @@ library VaultLibrary {
         IDsFlashSwapCore flashSwapRouter,
         uint256 lvRedeemed
     ) internal view returns (uint256 totalRa, uint256 lpLiquidated) {
-        (uint256 raPerLv, uint256 ctPerLv, uint256 raPerLp, uint256 ctPerLp) =
-            __calculateCtBalanceWithRate(self, flashSwapRouter, dsId);
+        uint256 lvReserve = flashSwapRouter.getLvReserve(self.info.toId(), dsId);
+
+        (uint256 raPerLv,, uint256 raPerLp,) = __calculateCtBalanceWithRate(self, flashSwapRouter, dsId);
 
-        totalRa = (raPerLv * lvRedeemed) / 1e18;
-        uint256 ammCtBalance = (ctPerLv * lvRedeemed) / 1e18;
+        (uint256 raReserve, uint256 ctReserve) = _getRaCtReserveSorted(self, flashSwapRouter, dsId);
 
+        // calculate how much LP we need to liquidate to redeem the LV
         lpLiquidated = MathHelper.convertToLp(raPerLv, raPerLp, lvRedeemed);
 
+        uint256 lpTotalSupply = flashSwapRouter.getUniV2pair(self.info.toId(), dsId).totalSupply();
+        // totalRa we remove
+        totalRa = lpLiquidated * raReserve / lpTotalSupply;
+
+        // total Ct we remove
+        uint256 ammCtBalance = lpLiquidated * ctReserve / lpTotalSupply;
+
         // pair DS and CT to redeem RA
-        totalRa += flashSwapRouter.getLvReserve(self.info.toId(), dsId) > ammCtBalance
-            ? ammCtBalance
-            : flashSwapRouter.getLvReserve(self.info.toId(), dsId);
+        totalRa += lvReserve > ammCtBalance ? ammCtBalance : lvReserve;
+
+        uint256 excessCt = lvReserve > ammCtBalance ? 0 : ammCtBalance - lvReserve;
 
-        uint256 excessCt = flashSwapRouter.getLvReserve(self.info.toId(), dsId) > ammCtBalance
-            ? 0
-            : ammCtBalance - flashSwapRouter.getLvReserve(self.info.toId(), dsId);
+        totalRa += _trySellCtToAmm(self, dsId, flashSwapRouter, excessCt, lpLiquidated, lpTotalSupply);
+    }
+
+    function _getRaCtReserveSorted(State storage self, IDsFlashSwapCore flashSwapRouter, uint256 dsId)
+        internal
+        view
+        returns (uint256 raReserve, uint256 ctReserve)
+    {
+        (raReserve, ctReserve,) = flashSwapRouter.getUniV2pair(self.info.toId(), dsId).getReserves();
 
-        totalRa += _trySellCtToAmm(self, dsId, flashSwapRouter, excessCt, ctPerLp);
+        (raReserve, ctReserve) = MinimalUniswapV2Library.reverseSortWithAmount224(
+            flashSwapRouter.getUniV2pair(self.info.toId(), dsId).token0(),
+            flashSwapRouter.getUniV2pair(self.info.toId(), dsId).token1(),
+            self.info.pair1,
+            self.ds[dsId].ct,
+            raReserve,
+            ctReserve
+        );
     }
 
     function _trySellCtToAmm(
@@ -500,102 +635,18 @@ library VaultLibrary {
         uint256 dsId,
         IDsFlashSwapCore flashSwapRouter,
         uint256 excessCt,
-        uint256 ctPerLp
+        uint256 lpLiquidated,
+        uint256 lpTotalSupply
     ) internal view returns (uint256 ra) {
         if (excessCt == 0) {
             return 0;
         }
 
-        (uint256 raReserve, uint256 ctReserve,) = flashSwapRouter.getUniV2pair(self.info.toId(), dsId).getReserves();
-        uint256 ct = (excessCt * ctPerLp) / 1e18;
-        ra = MinimalUniswapV2Library.getAmountOut(ct, ctReserve, raReserve);
-    }
-
-    function redeemExpired(
-        State storage self,
-        address owner,
-        address receiver,
-        uint256 amount,
-        IUniswapV2Router02 ammRouter,
-        IDsFlashSwapCore flashSwapRouter,
-        bytes memory rawLvPermitSig,
-        uint256 deadline
-    ) external returns (uint256 attributedRa, uint256 attributedPa) {
-        {
-            uint256 dsId = self.globalAssetIdx;
-            DepegSwap storage ds = self.ds[dsId];
-
-            uint256 userEligible = self.vault.pool.withdrawEligible[owner];
-
-            if (userEligible == 0 && !ds.isExpired()) {
-                revert Unauthorized(owner);
-            }
-
-            // user can only redeem up to the amount they requested, when there's a DS active
-            // if there's no DS active, then there's no cap on the amount of LV that can be redeemed
-            if (!ds.isExpired() && userEligible < amount) {
-                revert InsufficientBalance(owner, amount, userEligible);
-            }
-
-            if (ds.isExpired() && !self.vault.lpLiquidated.get(dsId)) {
-                _liquidatedLp(self, dsId, ammRouter, flashSwapRouter);
-                assert(self.vault.balances.ra.locked == 0);
-            }
-        }
-
-        uint256 burnUserAmount;
-        uint256 burnSelfAmount;
-
-        (attributedRa, attributedPa, burnUserAmount, burnSelfAmount) = self.vault.pool.redeem(amount, owner);
-        assert(burnSelfAmount + burnUserAmount == amount);
-
-        if (deadline != 0) {
-            DepegSwapLibrary.permit(
-                self.vault.lv._address, rawLvPermitSig, owner, address(this), burnUserAmount, deadline
-            );
-        }
-        //ra
-        IERC20(self.info.pair1).safeTransfer(receiver, attributedRa);
-        //pa
-        IERC20(self.info.pair0).safeTransfer(receiver, attributedPa);
-
-        self.vault.lv.burnSelf(burnSelfAmount);
-
-        if (burnUserAmount != 0) {
-            ERC20Burnable(self.vault.lv._address).burnFrom(owner, burnUserAmount);
-        }
-    }
-
-    function previewRedeemExpired(State storage self, uint256 amount, address owner, IDsFlashSwapCore flashSwapRouter)
-        external
-        view
-        returns (uint256 attributedRa, uint256 attributedPa, uint256 approvedAmount)
-    {
-        DepegSwap storage ds = self.ds[self.globalAssetIdx];
-
-        if (self.vault.pool.withdrawEligible[owner] == 0 && !ds.isExpired()) {
-            revert Unauthorized(owner);
-        }
-
-        // user can only redeem up to the amount they requested, when there's a DS active
-        // if there's no DS active, then there's no cap on the amount of LV that can be redeemed
-        if (!ds.isExpired() && self.vault.pool.withdrawEligible[owner] < amount) {
-            revert InsufficientBalance(owner, amount, self.vault.pool.withdrawEligible[owner]);
-        }
-
-        VaultWithdrawalPool memory withdrawalPool = self.vault.pool.withdrawalPool;
-
-        VaultAmmLiquidityPool memory ammLiquidityPool = self.vault.pool.ammLiquidityPool;
-
-        if (ds.isExpired() && !self.vault.lpLiquidated.get(self.globalAssetIdx)) {
-            (uint256 totalRa, uint256 pa) = _tryLiquidateLpAndRedeemCtToPsm(self, self.globalAssetIdx, flashSwapRouter);
+        (uint256 raReserve, uint256 ctReserve) = _getRaCtReserveSorted(self, flashSwapRouter, dsId);
+        raReserve -= (lpLiquidated * raReserve) / lpTotalSupply;
+        ctReserve -= (lpLiquidated * ctReserve) / lpTotalSupply;
 
-            VaultPoolLibrary.tryReserve(withdrawalPool, ammLiquidityPool, self.vault.lv.totalIssued(), totalRa, pa);
-        }
-
-        (attributedRa, attributedPa, approvedAmount) = VaultPoolLibrary.tryRedeem(
-            self.vault.pool.withdrawEligible, withdrawalPool, ammLiquidityPool, amount, owner
-        );
+        ra = MinimalUniswapV2Library.getAmountOut(excessCt, ctReserve, raReserve);
     }
 
     // IMPORTANT : only psm, flash swap router and early redeem LV can call this function
@@ -607,7 +658,6 @@ library VaultLibrary {
     ) public {
         __provideLiquidityWithRatio(self, amount, flashSwapRouter, self.ds[self.globalAssetIdx].ct, ammRouter);
     }
-
     // taken directly from spec document, technically below is what should happen in this function
     //
     // '#' refers to the total circulation supply of that token.
@@ -636,6 +686,7 @@ library VaultLibrary {
     //
     // final amount(Fa) :
     // Fa = rA - fee(rA)
+
     function redeemEarly(
         State storage self,
         address owner,
@@ -644,38 +695,48 @@ library VaultLibrary {
         IDsFlashSwapCore flashSwapRouter,
         IUniswapV2Router02 ammRouter,
         bytes memory rawLvPermitSig,
-        uint256 deadline
-    ) external returns (uint256 received, uint256 fee, uint256 feePrecentage) {
+        uint256 permitDeadline,
+        uint256 amountOutMin,
+        uint256 ammDeadline
+    ) external returns (uint256 received, uint256 fee, uint256 feePercentage) {
         safeBeforeExpired(self);
-        if (deadline != 0) {
-            DepegSwapLibrary.permit(self.vault.lv._address, rawLvPermitSig, owner, address(this), amount, deadline);
+        if (permitDeadline != 0) {
+            DepegSwapLibrary.permit(
+                self.vault.lv._address, rawLvPermitSig, owner, address(this), amount, permitDeadline
+            );
         }
 
-        feePrecentage = self.vault.config.fee;
+        feePercentage = self.vault.config.fee;
+
+        received = _liquidateLpPartial(self, self.globalAssetIdx, flashSwapRouter, ammRouter, amount, ammDeadline);
 
-        received = _liquidateLpPartial(self, self.globalAssetIdx, flashSwapRouter, ammRouter, amount);
+        fee = MathHelper.calculatePercentageFee(received, feePercentage);
 
-        fee = MathHelper.calculatePrecentageFee(received, feePrecentage);
+        if (fee != 0) {
+            provideLiquidityWithFee(self, fee, flashSwapRouter, ammRouter);
+            received = received - fee;
+        }
 
-        provideLiquidityWithFee(self, fee, flashSwapRouter, ammRouter);
-        received = received - fee;
+        if (received < amountOutMin) {
+            revert InsufficientOutputAmount(amountOutMin, received);
+        }
 
         ERC20Burnable(self.vault.lv._address).burnFrom(owner, amount);
         self.vault.balances.ra.unlockToUnchecked(received, receiver);
     }
 
     function previewRedeemEarly(State storage self, uint256 amount, IDsFlashSwapCore flashSwapRouter)
-        external
+        public
         view
-        returns (uint256 received, uint256 fee, uint256 feePrecentage)
+        returns (uint256 received, uint256 fee, uint256 feePercentage)
     {
         safeBeforeExpired(self);
 
-        feePrecentage = self.vault.config.fee;
+        feePercentage = self.vault.config.fee;
 
         (received,) = _tryLiquidateLpAndSellCtToAmm(self, self.globalAssetIdx, flashSwapRouter, amount);
 
-        fee = MathHelper.calculatePrecentageFee(received, feePrecentage);
+        fee = MathHelper.calculatePercentageFee(received, feePercentage);
 
         received -= fee;
     }
