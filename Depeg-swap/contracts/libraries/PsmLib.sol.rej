diff a/Depeg-swap/contracts/libraries/PsmLib.sol b/Depeg-swap/contracts/libraries/PsmLib.sol	(rejected hunks)
@@ -1,4 +1,4 @@
-pragma solidity 0.8.24;
+pragma solidity ^0.8.24;
 
 import {Asset, ERC20Burnable} from "../core/assets/Asset.sol";
 import {Pair, PairLibrary} from "./Pair.sol";
@@ -30,13 +30,218 @@ library PsmLibrary {
     using BitMaps for BitMaps.BitMap;
     using SafeERC20 for IERC20;
 
-    function isInitialized(State storage self) internal view returns (bool status) {
+    /// @notice inssuficient balance to perform rollover redeem(e.g having 5 CT worth of rollover to redeem but trying to redeem 10)
+    error InsufficientRolloverBalance(address caller, uint256 requested, uint256 balance);
+
+    /// @notice thrown when trying to rollover while no active issuance
+    error NoActiveIssuance();
+
+    function isInitialized(State storage self) external view returns (bool status) {
         status = self.info.isInitialized();
     }
 
-    function initialize(State storage self, Pair memory key) internal {
+    function initialize(State storage self, Pair memory key, uint256 psmBaseRedemptionFee) external {
         self.info = key;
         self.psm.balances.ra = RedemptionAssetManagerLibrary.initialize(key.redemptionAsset());
+        self.psm.psmBaseRedemptionFeePercentage = psmBaseRedemptionFee;
+    }
+
+    function updateAutoSell(State storage self, address user, bool status) external {
+        self.psm.autoSell[user] = status;
+    }
+
+    function acceptRolloverProfit(State storage self, uint256 amount) external {
+        self.psm.poolArchive[self.globalAssetIdx].rolloverProfit += amount;
+    }
+
+    function tranferRolloverClaims(State storage self, address from, address to, uint256 amount, uint256 dsId)
+        external
+    {
+        if (self.psm.poolArchive[dsId].rolloverClaims[from] < amount) {
+            revert InsufficientRolloverBalance(from, amount, self.psm.poolArchive[dsId].rolloverClaims[from]);
+        }
+
+        self.psm.poolArchive[dsId].rolloverClaims[from] -= amount;
+        self.psm.poolArchive[dsId].rolloverClaims[to] += amount;
+    }
+
+    function rolloverCt(
+        State storage self,
+        address owner,
+        uint256 amount,
+        uint256 dsId,
+        IDsFlashSwapCore flashSwapRouter,
+        bytes memory rawCtPermitSig,
+        uint256 ctDeadline
+    ) external returns (uint256 ctReceived, uint256 dsReceived, uint256 _exchangeRate, uint256 paReceived) {
+        if (rawCtPermitSig.length > 0 && ctDeadline != 0) {
+            DepegSwapLibrary.permit(self.ds[dsId].ct, rawCtPermitSig, owner, address(this), amount, ctDeadline);
+        }
+
+        (ctReceived, dsReceived, _exchangeRate, paReceived) = _rolloverCt(self, owner, amount, dsId, flashSwapRouter);
+    }
+
+    function claimAutoSellProfit(
+        State storage self,
+        IDsFlashSwapCore flashSwapRouter,
+        address owner,
+        uint256 dsId,
+        uint256 amount
+    ) external returns (uint256 profit, uint256 remainingDsReceived) {
+        (profit, remainingDsReceived) =
+            _claimAutoSellProfit(self, self.psm.poolArchive[dsId], flashSwapRouter, owner, amount, dsId);
+    }
+    // 1. check how much expirec CT does use have
+    // 2. calculate how much backed RA and PA the user can redeem
+    // 3. mint new CT and DS equal to backed RA user has
+    // 4. send DS to flashswap router if user opt-in for auto sell or send to user if not
+    // 5. send CT to user
+    // 6. send RA to user if they don't opt-in for auto sell
+    // 7. send PA to user
+    // regardless of amount, it will always send user all the profit from rollover
+
+    function _rolloverCt(
+        State storage self,
+        address owner,
+        uint256 amount,
+        uint256 prevDsId,
+        IDsFlashSwapCore flashSwapRouter
+    ) internal returns (uint256 ctReceived, uint256 dsReceived, uint256 _exchangeRate, uint256 paReceived) {
+        if (prevDsId == self.globalAssetIdx) {
+            revert NoActiveIssuance();
+        }
+
+        // claim logic
+        PsmPoolArchive storage prevArchive;
+
+        uint256 accruedRa;
+        // avoid stack too deep error
+        (prevArchive, accruedRa, paReceived) = _claimCtForRollover(self, prevDsId, amount, owner);
+
+        // deposit logic
+        DepegSwap storage currentDs = self.ds[self.globalAssetIdx];
+        Guard.safeBeforeExpired(currentDs);
+
+        // calculate ct and ds received
+        _exchangeRate = currentDs.exchangeRate();
+        ctReceived = MathHelper.calculateDepositAmountWithExchangeRate(accruedRa, _exchangeRate);
+
+        // by default the amount of DS received is the same as CT
+        dsReceived = ctReceived;
+
+        // increase current ds active RA balance locked
+        self.psm.balances.ra.incLocked(accruedRa);
+
+        // increase rollover claims if user opt-in for auto sell, avoid stack too deep error
+        dsReceived = _incRolloverClaims(self, ctReceived, owner, dsReceived);
+        // end deposit logic
+
+        // send, burn tokens and mint new ones
+        _afterRollover(self, currentDs, owner, ctReceived, paReceived, flashSwapRouter);
+    }
+
+    function _incRolloverClaims(State storage self, uint256 ctDsReceived, address owner, uint256 dsReceived)
+        internal
+        returns (uint256)
+    {
+        if (self.psm.autoSell[owner]) {
+            PsmPoolArchive storage currentArchive = self.psm.poolArchive[self.globalAssetIdx];
+            currentArchive.attributedToRolloverProfit += ctDsReceived;
+            currentArchive.rolloverClaims[owner] += ctDsReceived;
+            // we return 0 since the user opt-in for auto sell
+            return 0;
+        } else {
+            return dsReceived;
+        }
+    }
+
+    function _claimCtForRollover(State storage self, uint256 prevDsId, uint256 amount, address owner)
+        private
+        returns (PsmPoolArchive storage prevArchive, uint256 accruedRa, uint256 accruedPa)
+    {
+        DepegSwap storage prevDs = self.ds[prevDsId];
+        Guard.safeAfterExpired(prevDs);
+
+        if (Asset(prevDs.ct).balanceOf(owner) < amount) {
+            revert InsufficientRolloverBalance(owner, amount, Asset(prevDs.ct).balanceOf(owner));
+        }
+
+        // separate liquidity first so that we can properly calculate the attributed amount
+        _separateLiquidity(self, prevDsId);
+        uint256 totalCtIssued = self.psm.poolArchive[prevDsId].ctAttributed;
+        prevArchive = self.psm.poolArchive[prevDsId];
+
+        // caclulate accrued RA and PA proportional to CT amount
+        (accruedPa, accruedRa) = _calcRedeemAmount(amount, totalCtIssued, prevArchive.raAccrued, prevArchive.paAccrued);
+        // accounting stuff(decrementing reserve etc)
+        _beforeCtRedeem(self, prevDs, prevDsId, amount, accruedPa, accruedRa);
+
+        // burn previous CT
+        // this would normally go on the end of the the overall logic but needed here to avoid stack to deep error
+        ERC20Burnable(prevDs.ct).burnFrom(owner, amount);
+    }
+
+    function _claimAutoSellProfit(
+        State storage self,
+        PsmPoolArchive storage prevArchive,
+        IDsFlashSwapCore flashswapRouter,
+        address owner,
+        uint256 amount,
+        uint256 prevDsId
+    ) private returns (uint256 rolloverProfit, uint256 remainingRolloverDs) {
+        if (prevArchive.rolloverClaims[owner] < amount) {
+            revert InsufficientRolloverBalance(owner, amount, prevArchive.rolloverClaims[owner]);
+        }
+
+        remainingRolloverDs = MathHelper.calculateAccrued(
+            amount, flashswapRouter.getPsmReserve(self.info.toId(), prevDsId), prevArchive.attributedToRolloverProfit
+        );
+
+        if (remainingRolloverDs != 0) {
+            flashswapRouter.emptyReservePartialPsm(self.info.toId(), prevDsId, remainingRolloverDs);
+        }
+
+        // calculate their share of profit
+        rolloverProfit =
+            MathHelper.calculateAccrued(amount, prevArchive.rolloverProfit, prevArchive.attributedToRolloverProfit);
+        // reset their claim
+        prevArchive.rolloverClaims[owner] -= amount;
+        // decrement total profit
+        prevArchive.rolloverProfit -= rolloverProfit;
+        // decrement total ct attributed to rollover
+        prevArchive.attributedToRolloverProfit -= amount;
+
+        IERC20(self.info.redemptionAsset()).safeTransfer(owner, rolloverProfit);
+
+        if (remainingRolloverDs != 0) {
+            // mint DS to user
+            IERC20(self.ds[prevDsId]._address).safeTransfer(owner, remainingRolloverDs);
+        }
+    }
+
+    function _afterRollover(
+        State storage self,
+        DepegSwap storage currentDs,
+        address owner,
+        uint256 ctDsReceived,
+        uint256 accruedPa,
+        IDsFlashSwapCore flashSwapRouter
+    ) private {
+        if (self.psm.autoSell[owner]) {
+            // send DS to flashswap router if auto sellf
+            Asset(currentDs._address).mint(address(this), ctDsReceived);
+            IERC20(currentDs._address).safeIncreaseAllowance(address(flashSwapRouter), ctDsReceived);
+
+            flashSwapRouter.addReservePsm(self.info.toId(), self.globalAssetIdx, ctDsReceived);
+        } else {
+            // mint DS to user
+            Asset(currentDs._address).mint(owner, ctDsReceived);
+        }
+
+        // mint new CT to user
+        Asset(currentDs.ct).mint(owner, ctDsReceived);
+        // transfer accrued PA to user
+        self.info.peggedAsset().asErc20().safeTransfer(owner, accruedPa);
     }
 
     /// @notice issue a new pair of DS, will fail if the previous DS isn't yet expired
@@ -58,7 +263,7 @@ library PsmLibrary {
         // essentially burn unpurchased ds as we're going in with a new issuance
         self.psm.balances.dsBalance = 0;
 
-        self.psm.repurchaseFeePrecentage = repurchaseFeePercent;
+        self.psm.repurchaseFeePercentage = repurchaseFeePercent;
         self.ds[idx] = DepegSwapLibrary.initialize(ds, ct, ammPair);
     }
 
@@ -70,10 +275,14 @@ library PsmLibrary {
         DepegSwap storage ds = self.ds[prevIdx];
         Guard.safeAfterExpired(ds);
 
+        PsmPoolArchive storage archive = self.psm.poolArchive[prevIdx];
+
         uint256 availableRa = self.psm.balances.ra.convertAllToFree();
         uint256 availablePa = self.psm.balances.paBalance;
 
-        self.psm.poolArchive[prevIdx] = PsmPoolArchive(availableRa, availablePa, IERC20(ds.ct).totalSupply());
+        archive.paAccrued = availablePa;
+        archive.raAccrued = availableRa;
+        archive.ctAttributed = IERC20(ds.ct).totalSupply();
 
         // reset current balances
         self.psm.balances.ra.reset();
@@ -85,7 +294,7 @@ library PsmLibrary {
     /// @notice deposit RA to the PSM
     /// @dev the user must approve the PSM to spend their RA
     function deposit(State storage self, address depositor, uint256 amount)
-        internal
+        external
         returns (uint256 dsId, uint256 received, uint256 _exchangeRate)
     {
         if (amount == 0) {
@@ -109,21 +318,45 @@ library PsmLibrary {
     // This is here just for semantics, since in the whitepaper, all the CT DS issuance
     // happens in the PSM, although they essentially lives in the same contract, we leave it here just for consistency sake
     //
-    // IMPORTANT/FIXME: this is unsafe because by issuing CT, we also lock an equal amount of RA into the PSM.
+    // IMPORTANT: this is unsafe because by issuing CT, we also lock an equal amount of RA into the PSM.
     // it is a must, that the LV won't count the amount being locked in the PSM as it's balances.
     // doing so would create a mismatch between the accounting balance and the actual token balance.
-    function unsafeIssueToLv(State storage self, uint256 amount) internal {
+    function unsafeIssueToLv(State storage self, uint256 amount) internal returns (uint256 received) {
         uint256 dsId = self.globalAssetIdx;
 
         DepegSwap storage ds = self.ds[dsId];
+        uint256 _exchangeRate = ds.exchangeRate();
 
         self.psm.balances.ra.incLocked(amount);
 
-        ds.issue(address(this), amount);
+        // add 1 for rounding error protection, ensure that the vault always has >= the amount of CT to be transferred
+        received = MathHelper.calculateDepositAmountWithExchangeRate(amount, _exchangeRate) + 1;
+
+        ds.issue(address(this), received);
     }
 
-    function lvRedeemRaWithCtDs(State storage self, uint256 amount, uint256 dsId) internal {
+    function lvRedeemRaWithCtDs(State storage self, uint256 amount, uint256 dsId) internal returns (uint256 ra) {
+        // separate if its hasnt been separated and is expired, if expired withdraw from archive, if not, decrease locked RA
+
         DepegSwap storage ds = self.ds[dsId];
+
+        uint256 rates = ds.exchangeRate();
+        ra = MathHelper.calculateRedeemAmountWithExchangeRate(amount, rates);
+
+        // separate liquidity if the DS is expired(if hasn't been separated)
+        if (ds.isExpired()) {
+            _separateLiquidity(self, dsId);
+            PsmPoolArchive storage archive = self.psm.poolArchive[dsId];
+
+            // because the PSM treats all CT issued(including to itself) as redeemable, we need to decrease the total amount of CT issued 
+            archive.ctAttributed -= amount;
+            archive.raAccrued -= ra;
+        } else {
+            // else we just decrease the locked RA, since all the RA is still locked state(will turn to attributed when separated at liquidity)
+            // this'll happen when someone redeem early
+            self.psm.balances.ra.decLocked(ra);
+        }
+
         ds.burnBothforSelf(amount);
     }
 
@@ -146,7 +379,7 @@ library PsmLibrary {
     /// @dev since we mint 1:1, we return the same amount,
     /// since rate only effective when redeeming with CT
     function previewDeposit(State storage self, uint256 amount)
-        internal
+        external
         view
         returns (uint256 ctReceived, uint256 dsReceived, uint256 dsId)
     {
@@ -165,7 +398,7 @@ library PsmLibrary {
     }
 
     function previewRedeemRaWithCtDs(State storage self, uint256 amount)
-        internal
+        external
         view
         returns (uint256 ra, uint256 dsId, uint256 rates)
     {
@@ -199,7 +432,7 @@ library PsmLibrary {
         uint256 dsDeadline,
         bytes memory rawCtPermitSig,
         uint256 ctDeadline
-    ) internal returns (uint256 ra, uint256 dsId, uint256 rates) {
+    ) external returns (uint256 ra, uint256 dsId, uint256 rates) {
         dsId = self.globalAssetIdx;
         DepegSwap storage ds = self.ds[dsId];
         Guard.safeBeforeExpired(ds);
@@ -211,7 +444,7 @@ library PsmLibrary {
         (ra, rates) = _redeemRaWithCtDs(self, ds, owner, amount);
     }
 
-    function availableForRepurchase(State storage self) internal view returns (uint256 pa, uint256 ds, uint256 dsId) {
+    function availableForRepurchase(State storage self) external view returns (uint256 pa, uint256 ds, uint256 dsId) {
         dsId = self.globalAssetIdx;
         DepegSwap storage _ds = self.ds[dsId];
         Guard.safeBeforeExpired(_ds);
@@ -220,7 +453,7 @@ library PsmLibrary {
         ds = self.psm.balances.dsBalance;
     }
 
-    function repurchaseRates(State storage self) internal view returns (uint256 rates) {
+    function repurchaseRates(State storage self) external view returns (uint256 rates) {
         uint256 dsId = self.globalAssetIdx;
         DepegSwap storage ds = self.ds[dsId];
         Guard.safeBeforeExpired(ds);
@@ -228,37 +461,39 @@ library PsmLibrary {
         rates = ds.exchangeRate();
     }
 
-    function repurchaseFeePrecentage(State storage self) internal view returns (uint256 rates) {
-        rates = self.psm.repurchaseFeePrecentage;
+    function repurchaseFeePercentage(State storage self) external view returns (uint256 rates) {
+        rates = self.psm.repurchaseFeePercentage;
     }
 
-    function updateRepurchaseFeePercentage(State storage self, uint256 newFees) internal {
+    function updateRepurchaseFeePercentage(State storage self, uint256 newFees) external {
         if (newFees > 5 ether) {
             revert ICommon.InvalidFees();
         }
-        self.psm.repurchaseFeePrecentage = newFees;
+        self.psm.repurchaseFeePercentage = newFees;
     }
 
     function updatePoolsStatus(
         State storage self,
         bool isPSMDepositPaused,
         bool isPSMWithdrawalPaused,
+        bool isPSMRepurchasePaused,
         bool isLVDepositPaused,
         bool isLVWithdrawalPaused
-    ) internal {
+    ) external {
         self.psm.isDepositPaused = isPSMDepositPaused;
         self.psm.isWithdrawalPaused = isPSMWithdrawalPaused;
+        self.psm.isRepurchasePaused = isPSMRepurchasePaused;
         self.vault.config.isDepositPaused = isLVDepositPaused;
         self.vault.config.isWithdrawalPaused = isLVWithdrawalPaused;
     }
 
     function previewRepurchase(State storage self, uint256 amount)
-        internal
+        public
         view
         returns (
             uint256 dsId,
             uint256 received,
-            uint256 feePrecentage,
+            uint256 feePercentage,
             uint256 fee,
             uint256 exchangeRates,
             DepegSwap storage ds
@@ -272,15 +507,13 @@ library PsmLibrary {
         exchangeRates = ds.exchangeRate();
 
         // the fee is taken directly from RA before it's even converted to DS
-        feePrecentage = self.psm.repurchaseFeePrecentage;
-        fee = MathHelper.calculatePrecentageFee(amount, feePrecentage);
+        feePercentage = self.psm.repurchaseFeePercentage;
+        fee = MathHelper.calculatePercentageFee(amount, feePercentage);
         amount = amount - fee;
 
         // we use deposit here because technically the user deposit RA to the PSM when repurchasing
         received = MathHelper.calculateDepositAmountWithExchangeRate(amount, exchangeRates);
 
-        received = received;
-
         uint256 available = self.psm.balances.paBalance;
         // ensure that we have an equal amount of DS and PA
         assert(available == self.psm.balances.dsBalance);
@@ -296,10 +529,10 @@ library PsmLibrary {
         uint256 amount,
         IDsFlashSwapCore flashSwapRouter,
         IUniswapV2Router02 ammRouter
-    ) internal returns (uint256 dsId, uint256 received, uint256 feePrecentage, uint256 fee, uint256 exchangeRates) {
+    ) external returns (uint256 dsId, uint256 received, uint256 feePercentage, uint256 fee, uint256 exchangeRates) {
         DepegSwap storage ds;
 
-        (dsId, received, feePrecentage, fee, exchangeRates, ds) = previewRepurchase(self, amount);
+        (dsId, received, feePercentage, fee, exchangeRates, ds) = previewRepurchase(self, amount);
 
         // decrease PSM balance
         // we also include the fee here to separate the accumulated fee from the repurchase
@@ -307,7 +540,12 @@ library PsmLibrary {
         self.psm.balances.dsBalance -= (received);
 
         // transfer user RA to the PSM/LV
-        self.psm.balances.ra.lockUnchecked(amount, buyer);
+        self.psm.balances.ra.lockFrom(amount, buyer);
+
+        // decrease the locked balance with the fee(if any), since the fee is used to provide liquidity
+        if (fee != 0) {
+            self.psm.balances.ra.decLocked(fee);
+        }
 
         // transfer user attrubuted DS + PA
         // PA
@@ -315,10 +553,12 @@ library PsmLibrary {
         IERC20(pa).safeTransfer(buyer, received);
 
         // DS
-        IERC20(ds._address).transfer(buyer, received);
+        IERC20(ds._address).safeTransfer(buyer, received);
 
-        // Provide liquidity
-        VaultLibrary.provideLiquidityWithFee(self, fee, flashSwapRouter, ammRouter);
+        if (fee != 0) {
+            // Provide liquidity with fee(if any)
+            VaultLibrary.__provideLiquidityWithRatio(self, fee, flashSwapRouter, ds.ct,  ammRouter);
+        }
     }
 
     function _redeemDs(Balances storage self, uint256 amount) internal {
@@ -331,26 +571,28 @@ library PsmLibrary {
         DepegSwap storage ds,
         address owner,
         uint256 amount,
-        uint256 feePrecentage
+        uint256 feePercentage
     ) internal returns (uint256 received, uint256 _exchangeRate, uint256 fee) {
-        IERC20(ds._address).transferFrom(owner, address(this), amount);
+        IERC20(ds._address).safeTransferFrom(owner, address(this), amount);
 
         _exchangeRate = ds.exchangeRate();
         received = MathHelper.calculateRedeemAmountWithExchangeRate(amount, _exchangeRate);
 
-        fee = MathHelper.calculatePrecentageFee(received, feePrecentage);
+        fee = MathHelper.calculatePercentageFee(received, feePercentage);
         received -= fee;
 
         IERC20(self.info.peggedAsset().asErc20()).safeTransferFrom(owner, address(this), amount);
 
         self.psm.balances.ra.unlockTo(owner, received);
+        // we decrease the locked value, as we're going to use this to provide liquidity to the LV
+        self.psm.balances.ra.decLocked(fee);
     }
 
-    function valueLocked(State storage self) internal view returns (uint256) {
+    function valueLocked(State storage self) external view returns (uint256) {
         return self.psm.balances.ra.locked;
     }
 
-    function exchangeRate(State storage self) internal view returns (uint256 rates) {
+    function exchangeRate(State storage self) external view returns (uint256 rates) {
         uint256 dsId = self.globalAssetIdx;
         DepegSwap storage ds = self.ds[dsId];
         rates = ds.exchangeRate();
@@ -367,35 +609,33 @@ library PsmLibrary {
         uint256 amount,
         uint256 dsId,
         bytes memory rawDsPermitSig,
-        uint256 deadline,
-        uint256 feePrecentage
-    ) internal returns (uint256 received, uint256 _exchangeRate, uint256 fee) {
+        uint256 deadline
+    ) external returns (uint256 received, uint256 _exchangeRate, uint256 fee) {
         DepegSwap storage ds = self.ds[dsId];
         Guard.safeBeforeExpired(ds);
         if (deadline != 0) {
             DepegSwapLibrary.permit(ds._address, rawDsPermitSig, owner, address(this), amount, deadline);
         }
         _redeemDs(self.psm.balances, amount);
-        (received, _exchangeRate, fee) = _afterRedeemWithDs(self, ds, owner, amount, feePrecentage);
+        (received, _exchangeRate, fee) = _afterRedeemWithDs(self, ds, owner, amount, self.psm.psmBaseRedemptionFeePercentage);
     }
 
     /// @notice simulate a ds redeem.
     /// @return assets how much RA the user would receive
     function previewRedeemWithDs(State storage self, uint256 dsId, uint256 amount)
-        internal
+        external
         view
-        returns (uint256 assets)
+        returns (uint256 assets, uint256 fee)
     {
         DepegSwap storage ds = self.ds[dsId];
         Guard.safeBeforeExpired(ds);
-
-        uint256 normalizedRateAmount = MathHelper.calculateRedeemAmountWithExchangeRate(amount, ds.exchangeRate());
-
-        assets = normalizedRateAmount;
+        assets = MathHelper.calculateRedeemAmountWithExchangeRate(amount, ds.exchangeRate());
+        fee = MathHelper.calculatePercentageFee(assets, self.psm.psmBaseRedemptionFeePercentage);
+        assets -= fee;
     }
 
     /// @notice return the next depeg swap expiry
-    function nextExpiry(State storage self) internal view returns (uint256 expiry) {
+    function nextExpiry(State storage self) external view returns (uint256 expiry) {
         uint256 idx = self.globalAssetIdx;
 
         DepegSwap storage ds = self.ds[idx];
@@ -435,7 +675,7 @@ library PsmLibrary {
         uint256 accruedPa,
         uint256 accruedRa
     ) internal {
-        IERC20(ds.ct).transferFrom(owner, address(this), ctRedeemedAmount);
+        ERC20Burnable(ds.ct).burnFrom(owner, ctRedeemedAmount);
         IERC20(self.info.peggedAsset().asErc20()).safeTransfer(owner, accruedPa);
         IERC20(self.info.redemptionAsset()).safeTransfer(owner, accruedRa);
     }
@@ -452,7 +692,7 @@ library PsmLibrary {
         uint256 dsId,
         bytes memory rawCtPermitSig,
         uint256 deadline
-    ) internal returns (uint256 accruedPa, uint256 accruedRa) {
+    ) external returns (uint256 accruedPa, uint256 accruedRa) {
         DepegSwap storage ds = self.ds[dsId];
         Guard.safeAfterExpired(ds);
         if (deadline != 0) {
@@ -474,7 +714,7 @@ library PsmLibrary {
     /// @return accruedPa the amount of PA the user would receive
     /// @return accruedRa the amount of RA the user would receive
     function previewRedeemWithCt(State storage self, uint256 dsId, uint256 amount)
-        internal
+        external
         view
         returns (uint256 accruedPa, uint256 accruedRa)
     {
@@ -494,4 +734,12 @@ library PsmLibrary {
 
         (accruedPa, accruedRa) = _calcRedeemAmount(amount, totalCtIssued, availableRa, availablePa);
     }
+
+    function updatePSMBaseRedemptionFeePercentage(State storage self, uint256 newFees) external {
+        if (newFees > 5 ether) {
+            revert ICommon.InvalidFees();
+        }
+        self.psm.psmBaseRedemptionFeePercentage = newFees;
+    }
+
 }
